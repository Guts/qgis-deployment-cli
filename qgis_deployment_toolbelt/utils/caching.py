#! python3  # noqa: E265

"""Helpers to cache objects."""


# #############################################################################
# ########## Libraries #############
# ##################################


# Standard library
import gc
import logging
from datetime import datetime, timedelta
from functools import _lru_cache_wrapper, lru_cache, wraps

# #############################################################################
# ########## Globals ###############
# ##################################

# logs
logger = logging.getLogger(__name__)

# #############################################################################
# ########## Functions #############
# ##################################


def cache_clearer(only_already_hit: bool = True):
    """Clear all LRU cached functions.

    Args:
        only_already_hit (bool, optional): option to clear cache only for functions
            which have been already hit.. Defaults to True.
    """
    # collect wrappers in the garbage collector
    gc.collect()
    # filter on the LRU cache wrappers generated by the package
    cache_wrappers = (
        a
        for a in gc.get_objects()
        if isinstance(a, _lru_cache_wrapper)
        and "qgis_deployment_toolbelt" in a.__module__
    )

    # clear cached function which have already been hit
    for cached in cache_wrappers:
        if only_already_hit and cached.cache_info().hits > 0:
            logger.debug(
                "Cache cleared for: {}.{} which was hit {} times".format(
                    cached.__module__, cached.__name__, cached.cache_info().hits
                )
            )
            cached.cache_clear()
        elif only_already_hit:
            continue
        else:
            logger.debug(
                "Cache cleared for: {}.{} which was hit {} times".format(
                    cached.__module__, cached.__name__, cached.cache_info().hits
                )
            )
            cached.cache_clear()
            continue


def timed_lru_cache(seconds: int = 60, maxsize: int = 128):
    """Enhanced lru_cache decorator with expiration time.

    Source: https://realpython.com/lru-cache-python/#caching-articles-with-the-new-decorator

    Args:
        seconds (int, optional): lifetime in seconds. Defaults to 60.
        maxsize (int, optional): cache size. Defaults to 128.
    """

    def wrapper_cache(func):
        func = lru_cache(maxsize=maxsize)(func)

        func.lifetime = timedelta(seconds=seconds)

        func.expiration = datetime.utcnow() + func.lifetime

        @wraps(func)
        def wrapped_func(*args, **kwargs):
            if datetime.utcnow() >= func.expiration:
                func.cache_clear()

                func.expiration = datetime.utcnow() + func.lifetime

            return func(*args, **kwargs)

        return wrapped_func

    return wrapper_cache
